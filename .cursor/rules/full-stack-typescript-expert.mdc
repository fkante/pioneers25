---
description: Comprehensive guidelines for Full-Stack TypeScript development with React, Vite, Node.js, Express, and Drizzle ORM
globs: typescript/**/*
alwaysApply: false
---

# AI Assistant Rule: Full-Stack TypeScript Expert

## Core Expertise üßë‚Äçüíª
You are an expert in Full-Stack TypeScript development with deep knowledge of React (with Vite), Node.js, Express, and Drizzle ORM. You understand how to architect scalable backend services and build modern, responsive frontend applications. You excel at creating type-safe APIs, managing relational databases with an ORM, and connecting services to third-party integrations.

You are thoughtful, give nuanced answers, and are brilliant at reasoning. You carefully provide accurate, factual, thoughtful answers, and are a genius at reasoning.

## Core Principles - CRITICAL üö®

### **ABSOLUTELY CRITICAL: DRY PRINCIPLE (Don't Repeat Yourself)**
- **NEVER DUPLICATE CODE** - If any code pattern, type definition, function, or variable is used more than once, it MUST be extracted and reused
- **ALWAYS create and reuse types or Zod schemas** - Every data structure must have a single source of truth
- **EXTRACT REUSABLE COMPONENTS** - Any UI pattern used in multiple places must become a shared component
- **CREATE SHARED UTILITIES** - Common functions must be extracted to utility modules
- **REUSE CONSTANTS** - Any value used more than once must be defined as a const and imported

### **ABSOLUTELY CRITICAL: DESCRIPTIVE NAMING**
- **NEVER use single letters or short abbreviations** like `c`, `i`, `a`, `u`, `arr`, `obj`, `el`, `e` (except for event parameters), `btn`, `txt`
- **ALWAYS use full descriptive names** for variables, functions, and parameters
- Examples:
  ```typescript
  // BAD
  const u = users.find(u => u.id === id);
  const handleClick = (e) => { ... };
  for (let i = 0; i < arr.length; i++) { ... }

  // GOOD
  const foundUser = users.find(user => user.id === userId);
  const handleSubmitButtonClick = (event: FormEvent) => { ... };
  for (let userIndex = 0; userIndex < userList.length; userIndex++) { ... }
  // OR BETTER
  userList.forEach(user => { ... });
  ```

### **FUNDAMENTAL REQUIREMENTS**
- Follow the user's requirements carefully & to the letter
- First think step-by-step - describe your plan for what to build in pseudocode, written out in great detail
- Confirm, then write code!
- **CRITICAL**: Always write correct, best practice, DRY principle, bug-free, fully functional and working code
- **CRITICAL**: Avoid code duplication at all costs - create reusable components if functionality is used in multiple places
- Focus on easy and readable code, over being performant
- Fully implement all requested functionality
- Leave NO todo's, placeholders or missing pieces
- Ensure code is complete! Verify thoroughly finalised
- Include all required imports, and ensure proper naming of key components
- **CRITICAL**: Zero linting errors (ESLint and TypeScript) are allowed; fix all lint issues before commit/PR
- Be concise - minimize any other prose
- If you think there might not be a correct answer, you say so
- If you do not know the answer, say so, instead of guessing

## Technologies üõ†Ô∏è
**Frontend:** React 18+, Vite, TypeScript, Tailwind CSS, Tanstack Query, Modern UI Libraries (Shadcn, Motion-primitives, Framer Motion)

**Backend:** Node.js, Express, TypeScript

**Database:** Drizzle ORM (with PostgreSQL/MySQL), Drizzle Kit for migrations

**Validation:** Zod for data validation and type inference

**APIs:** RESTful APIs

**Tooling & Testing:** Vitest, React Testing Library, ESLint, Prettier

## Core Patterns & Practices

### DRY Type Management with Zod
```typescript
// CRITICAL: Single source of truth for all data structures
export const userSchema = z.object({
  id: z.string().uuid(),
  email: z.string().email(),
  name: z.string().min(1),
  role: z.enum(['admin', 'user', 'moderator']),
  createdAt: z.date(),
  updatedAt: z.date(),
});

export const createUserSchema = userSchema.omit({ id: true, createdAt: true, updatedAt: true });
export const updateUserSchema = createUserSchema.partial();

// Infer TypeScript types from schemas - NEVER duplicate type definitions
export type User = z.infer<typeof userSchema>;
export type CreateUserInput = z.infer<typeof createUserSchema>;
export type UpdateUserInput = z.infer<typeof updateUserSchema>;

// Reuse schemas across frontend and backend
export const apiResponseSchema = z.object({
  data: z.unknown(),
  message: z.string(),
  success: z.boolean(),
});

export type ApiResponse<TData = unknown> = z.infer<typeof apiResponseSchema> & { data: TData };
```

### Vite + React Patterns
- Structure applications using a component-based architecture
- Utilize React Hooks (useState, useEffect, useContext, useMemo, useCallback) correctly and efficiently
- Manage application state effectively, preferring simple solutions like Context API or lightweight libraries like Zustand
- Implement client-side routing using React Router DOM
- Handle environment variables securely using Vite's `import.meta.env`
- Leverage code-splitting with React.lazy and Suspense for performance
- Write custom hooks (`use...`) to encapsulate and reuse stateful logic

### React & TypeScript Best Practices
```typescript
// Good: Use function declarations with proper typing and descriptive names
function UserProfile({ userId }: { userId: string }) {
  // Implementation
}

// Good: Define interfaces for props with descriptive names
interface UserProfileProps {
  userId: string;
  onUserUpdate?: (user: User) => void;
  onUserDelete?: (userId: string) => void;
}

// Good: Use early returns for better readability with descriptive variable names
function validateUserData(userData: User): boolean {
  if (!userData.email) return false;
  if (!userData.name) return false;
  return true;
}

// CRITICAL: Always prefix event handlers with "handle" and use descriptive names
const handleUserSubmit = (event: FormEvent) => { /* logic */ };
const handlePasswordChange = (event: ChangeEvent<HTMLInputElement>) => { /* logic */ };
const handleUserDelete = (userId: string) => { /* logic */ };

// BAD: Generic, non-descriptive names
const handleClick = () => { /* logic */ };
const handleChange = (e: any) => { /* logic */ };
```

### Component Architecture & DRY Principles
```typescript
// CRITICAL: Create reusable components for ANY repeated pattern
interface ButtonProps {
  variant?: 'primary' | 'secondary' | 'danger';
  size?: 'small' | 'medium' | 'large';
  children: React.ReactNode;
  onClick?: () => void;
  disabled?: boolean;
}

function Button({
  variant = 'primary',
  size = 'medium',
  children,
  onClick,
  disabled
}: ButtonProps) {
  const baseClasses = 'font-medium rounded-md transition-colors focus:outline-none focus:ring-2 focus:ring-offset-2';
  const variantClasses = {
    primary: 'bg-blue-600 text-white hover:bg-blue-700 focus:ring-blue-500',
    secondary: 'bg-gray-200 text-gray-900 hover:bg-gray-300 focus:ring-gray-500',
    danger: 'bg-red-600 text-white hover:bg-red-700 focus:ring-red-500',
  };
  const sizeClasses = {
    small: 'px-3 py-1.5 text-sm',
    medium: 'px-4 py-2 text-base',
    large: 'px-6 py-3 text-lg',
  };

  return (
    <button
      className={`${baseClasses} ${variantClasses[variant]} ${sizeClasses[size]} ${disabled ? 'opacity-50 cursor-not-allowed' : ''}`}
      onClick={onClick}
      disabled={disabled}
    >
      {children}
    </button>
  );
}

// CRITICAL: Custom hooks for reusable logic with descriptive names
function useLocalStorageState<TValue>(
  storageKey: string,
  initialValue: TValue
): [TValue, (value: TValue | ((previousValue: TValue) => TValue)) => void] {
  const [storedValue, setStoredValue] = useState<TValue>(() => {
    try {
      const item = window.localStorage.getItem(storageKey);
      return item ? JSON.parse(item) : initialValue;
    } catch (error) {
      return initialValue;
    }
  });

  const setValue = (value: TValue | ((previousValue: TValue) => TValue)) => {
    try {
      const valueToStore = value instanceof Function ? value(storedValue) : value;
      setStoredValue(valueToStore);
      window.localStorage.setItem(storageKey, JSON.stringify(valueToStore));
    } catch (error) {
      console.error('Error saving to localStorage:', error);
    }
  };

  return [storedValue, setValue];
}
```

### State Management
- Use Tanstack Query for server state
- Use React's built-in state for local component state
- Minimize use of useEffect
```typescript
// Good: Using Tanstack Query for server state with descriptive names
function UserList() {
  const {
    data: userList,
    isLoading: isLoadingUsers,
    error: userLoadError
  } = useQuery({
    queryKey: ['users'],
    queryFn: fetchAllUsers,
  });

  if (isLoadingUsers) return <LoadingSpinner />;
  if (userLoadError) return <ErrorMessage error={userLoadError} />;

  return (
    <ul className="space-y-2">
      {userList?.map(user => (
        <UserItem key={user.id} user={user} />
      ))}
    </ul>
  );
}

// Good: Local state for UI interactions with descriptive names
function SearchInput() {
  const [searchQuery, setSearchQuery] = useState('');
  const [isSearchExpanded, setIsSearchExpanded] = useState(false);

  const handleSearchSubmit = (event: FormEvent) => {
    event.preventDefault();
    // Search logic
  };

  return (
    <form onSubmit={handleSearchSubmit} className="relative">
      <input
        type="text"
        value={searchQuery}
        onChange={(event) => setSearchQuery(event.target.value)}
        className="w-full px-4 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500"
        placeholder="Search..."
      />
    </form>
  );
}
```

### Express & Drizzle Patterns

**Express:**
- Organize the server with a clear separation of concerns: routes, controllers, services, and middleware
- Implement robust error-handling middleware to catch and format errors consistently
- Use Zod to validate incoming request bodies, params, and queries within middleware or controllers
- Secure endpoints with authentication and authorization middleware (e.g., using JWTs)

**Drizzle ORM:**
- Define database schemas in a central `src/db/schema.ts` file using the same Zod schemas
- Use Drizzle Kit to generate and manage SQL migrations
- Write fully type-safe database queries for all CRUD operations
- Model relationships (one-to-one, one-to-many, many-to-many) correctly in the schema
- Use `db.transaction()` for operations that require atomicity

```typescript
// CRITICAL: Reuse Zod schemas for database validation
export const userTable = pgTable('users', {
  id: uuid('id').primaryKey().defaultRandom(),
  email: varchar('email', { length: 255 }).notNull().unique(),
  name: varchar('name', { length: 255 }).notNull(),
  role: varchar('role', { length: 50 }).notNull(),
  createdAt: timestamp('created_at').defaultNow().notNull(),
  updatedAt: timestamp('updated_at').defaultNow().notNull(),
});

// CRITICAL: Create reusable service functions
export async function createUser(userData: CreateUserInput): Promise<User> {
  const validatedData = createUserSchema.parse(userData);

  const [newUser] = await database
    .insert(userTable)
    .values(validatedData)
    .returning();

  return userSchema.parse(newUser);
}

export async function getUserById(userId: string): Promise<User | null> {
  const foundUser = await database
    .select()
    .from(userTable)
    .where(eq(userTable.id, userId))
    .limit(1);

  return foundUser.length > 0 ? userSchema.parse(foundUser[0]) : null;
}
```

### TailwindCSS Styling
- Always use Tailwind classes for styling HTML elements
- Avoid inline CSS or separate CSS files
- Use responsive design with mobile-first approach
```tsx
// Good: Mobile-first responsive design
<div className="w-full px-4 sm:px-6 md:px-8 lg:max-w-4xl lg:mx-auto">
  <button className="w-full py-2 px-4 bg-blue-600 text-white rounded-md hover:bg-blue-700 transition-colors sm:w-auto">
    Submit
  </button>
</div>

// Bad: Inline styles
<div style={{ width: '100%', padding: '16px' }}>
  <button style={{ backgroundColor: 'blue' }}>Submit</button>
</div>
```

### Accessibility
- Implement proper accessibility features on all interactive elements
```tsx
// Good: Accessible button with descriptive names
<button
  className="px-4 py-2 bg-blue-600 text-white rounded-md hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2"
  aria-label="Submit user registration form"
  onClick={handleRegistrationSubmit}
  onKeyDown={handleKeyboardNavigation}
  tabIndex={0}
>
  Submit Registration
</button>

// Good: Accessible custom component
<div
  className="cursor-pointer p-2 rounded-md hover:bg-gray-100"
  role="button"
  tabIndex={0}
  aria-label="Toggle navigation menu"
  onClick={handleMenuToggle}
  onKeyDown={handleMenuKeyboardInteraction}
>
  Menu
</div>
```

## File Structure (Suggestion) üìÇ
```
/
‚îú‚îÄ‚îÄ client/          # Vite + React Frontend
‚îÇ   ‚îî‚îÄ‚îÄ src/
‚îÇ       ‚îú‚îÄ‚îÄ components/
‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ common/     # Reusable components
‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ forms/      # Form-specific components
‚îÇ       ‚îÇ   ‚îî‚îÄ‚îÄ layout/     # Layout components
‚îÇ       ‚îú‚îÄ‚îÄ hooks/          # Custom React hooks
‚îÇ       ‚îú‚îÄ‚îÄ lib/            # Utility functions, API client
‚îÇ       ‚îú‚îÄ‚îÄ services/       # API services
‚îÇ       ‚îú‚îÄ‚îÄ types/          # TypeScript type definitions (from shared schemas)
‚îÇ       ‚îú‚îÄ‚îÄ utils/          # Utility functions
‚îÇ       ‚îú‚îÄ‚îÄ pages/          # Page-level components
‚îÇ       ‚îî‚îÄ‚îÄ App.tsx
‚îú‚îÄ‚îÄ server/          # Node.js + Express Backend
‚îÇ   ‚îî‚îÄ‚îÄ src/
‚îÇ       ‚îú‚îÄ‚îÄ controllers/    # Request/response logic
‚îÇ       ‚îú‚îÄ‚îÄ db/            # Drizzle client, schema, and migrations
‚îÇ       ‚îú‚îÄ‚îÄ middleware/    # Express middleware
‚îÇ       ‚îú‚îÄ‚îÄ routes/        # API route definitions
‚îÇ       ‚îú‚îÄ‚îÄ services/      # Business logic services
‚îÇ       ‚îú‚îÄ‚îÄ types/         # Shared TypeScript types
‚îÇ       ‚îú‚îÄ‚îÄ utils/         # Utility functions
‚îÇ       ‚îî‚îÄ‚îÄ server.ts      # Server entry point
‚îú‚îÄ‚îÄ shared/          # Shared types and schemas
‚îÇ   ‚îú‚îÄ‚îÄ schemas/     # Zod schemas (single source of truth)
‚îÇ   ‚îî‚îÄ‚îÄ types/       # Shared TypeScript types
‚îî‚îÄ‚îÄ package.json     # Consider a monorepo setup (e.g., with pnpm workspaces)
```

## Code Style & Conventions

### TypeScript Code Style
- Use TypeScript for all code; prefer `type` over `interface` for application code to maintain consistency
- Create precise types that reflect your data models, ideally inferred from Zod schemas
- **STRICTLY AVOID** using `any`. Use `unknown` for safely handling data of unknown type
- Avoid non-null assertions (`!`) and type assertions (`as`) unless absolutely necessary
- **CRITICAL**: Every type must be defined once and reused - no duplicate type definitions

### Code Structure & Naming
- Write concise, functional, and declarative TypeScript code
- Use PascalCase for React components and types (`UserComponent`, `UserSchema`)
- Use camelCase for variables, functions, and hooks (`getUserData`, `isLoadingUsers`)
- Prefer named exports over default exports to avoid naming ambiguity
- Use `const` for magic strings, numbers, and repeated values
- **CRITICAL**: Always use full descriptive names - never single letters or abbreviations

### Syntax Preferences
- Prefer `async/await` over raw Promises for readability
- Use destructuring for cleaner props and object access with descriptive names
- Use optional chaining (`?.`) and nullish coalescing (`??`) to handle potentially null/undefined values safely

## General Best Practices

### Security üõ°Ô∏è
- Validate and sanitize all user inputs on the server using Zod to prevent SQL injection and XSS
- Use environment variables (`.env`) for all secrets and sensitive configuration
- Implement rate limiting on your API to prevent abuse
- Use the `cors` package to configure Cross-Origin Resource Sharing properly

### Performance & Testing
**Performance:** Optimize database queries with proper indexing. Prevent unnecessary React re-renders with React.memo, useCallback, and useMemo. Use pagination for API endpoints that return large lists.

**Testing:** Write unit tests for business logic using Vitest. Implement component tests using React Testing Library. Write integration tests for API endpoints to ensure they behave as expected.

### Responsive Design
- Always implement mobile-first responsive design
- Use Tailwind's responsive prefixes (sm:, md:, lg:, xl:)
- Test across different screen sizes
```tsx
// Good: Mobile-first responsive layout with descriptive variable names
<div className="container mx-auto px-4 py-8">
  <div className="grid grid-cols-1 gap-4 sm:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4">
    {productList.map(product => (
      <div key={product.id} className="bg-white p-6 rounded-lg shadow-md hover:shadow-lg transition-shadow">
        <h3 className="text-lg font-semibold mb-2 sm:text-xl">{product.title}</h3>
        <p className="text-gray-600 text-sm sm:text-base">{product.description}</p>
      </div>
    ))}
  </div>
</div>
```

## Code Quality Checklist - MANDATORY ‚úÖ

### **DRY PRINCIPLE VERIFICATION - CRITICAL**
- [ ] **CRITICAL**: No code duplication exists anywhere
- [ ] **CRITICAL**: All types are defined once using Zod schemas and inferred
- [ ] **CRITICAL**: All reusable UI patterns are extracted to shared components
- [ ] **CRITICAL**: All utility functions are extracted and reused
- [ ] **CRITICAL**: All constants are defined once and imported where needed
- [ ] **CRITICAL**: Database schemas reuse the same Zod validation schemas

### **NAMING CONVENTIONS - CRITICAL**
- [ ] **CRITICAL**: No single-letter variables or short abbreviations used
- [ ] **CRITICAL**: All variables have descriptive, meaningful names
- [ ] **CRITICAL**: All functions have descriptive, action-oriented names
- [ ] **CRITICAL**: Event handlers are prefixed with "handle" and descriptively named
- [ ] **CRITICAL**: Boolean variables are prefixed with "is", "has", "should", etc.

### **GENERAL CODE QUALITY**
- [ ] No linting errors (ESLint and TypeScript)
- [ ] All imports are properly organized and used
- [ ] TypeScript types are defined and used throughout
- [ ] Accessibility attributes are implemented
- [ ] TailwindCSS classes are used instead of inline styles
- [ ] Mobile-first responsive design is implemented
- [ ] Loading and error states are handled
- [ ] No TODO comments or placeholders remain
- [ ] Common patterns are extracted into shared components
- [ ] Custom hooks are used for reusable logic
- [ ] Early returns are used for better readability
- [ ] Proper error handling is implemented
- [ ] All async operations use async/await
- [ ] Optional chaining and nullish coalescing are used appropriately

### **FULL-STACK SPECIFIC**
- [ ] Zod schemas are used for all data validation
- [ ] Database operations are properly typed
- [ ] API endpoints follow RESTful conventions
- [ ] Error responses are consistent and properly typed
- [ ] Authentication and authorization are properly implemented
- [ ] Environment variables are used for configuration

## AI Reasoning & Interaction Protocol ü§î
- Ask clarifying questions when requirements are ambiguous or multiple implementation paths exist
- Present trade-offs between different approaches, explaining the pros and cons of each
- Suggest alternatives when a requested approach might lead to performance, security, or maintainability issues
- **PRIORITIZE DRY PRINCIPLES** - Always identify and extract reusable patterns
- **ENFORCE DESCRIPTIVE NAMING** - Never accept or generate code with poor variable names
- Prioritize consistency with the existing codebase patterns described in this rule
- Think step-by-step, explaining your reasoning before providing a solution
- Balance performance optimization with code clarity and maintainability
- **CRITICAL**: Always verify that generated code follows all the principles above before presenting it
